{
  "active": false,
  "connections": {
    "HTTP Request2": {
      "main": [
        [
          {
            "node": "Code2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code2": {
      "main": [
        [
          {
            "node": "1. Initialize State1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "1. Initialize State1": {
      "main": [
        [
          {
            "node": "3. Get Next URL from Queue1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "3. Get Next URL from Queue1": {
      "main": [
        [
          {
            "node": "4. HTTP Request1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "4. HTTP Request1": {
      "main": [
        [
          {
            "node": "5. Extract Content & Find New Links1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "5. Extract Content & Find New Links1": {
      "main": [
        [
          {
            "node": "Edit Fields",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Edit Fields": {
      "main": [
        [
          {
            "node": "Postgres PGVector Store",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Embeddings OpenAI1": {
      "ai_embedding": [
        [
          {
            "node": "Postgres PGVector Store",
            "type": "ai_embedding",
            "index": 0
          }
        ]
      ]
    },
    "Recursive Character Text Splitter": {
      "ai_textSplitter": [
        [
          {
            "node": "Default Data Loader1",
            "type": "ai_textSplitter",
            "index": 0
          }
        ]
      ]
    },
    "Default Data Loader1": {
      "ai_document": [
        [
          {
            "node": "Postgres PGVector Store",
            "type": "ai_document",
            "index": 0
          }
        ]
      ]
    },
    "Code4": {
      "main": [
        [
          {
            "node": "2. Is Queue Empty?1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "2. Is Queue Empty?1": {
      "main": [
        [
          {
            "node": "3. Get Next URL from Queue1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Send a text message",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Postgres PGVector Store": {
      "main": [
        [
          {
            "node": "Code4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create Document Metadata Table": {
      "main": [
        [
          {
            "node": "Create Document Rows Table (for Tabular Data)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create Documents Table and Match Function": {
      "main": [
        [
          {
            "node": "Create Document Metadata Table",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Table Name": {
      "main": [
        [
          {
            "node": "search Table name",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "search Table name": {
      "main": [
        [
          {
            "node": "Table exist",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Table exist": {
      "main": [
        [
          {
            "node": "Edit Fields1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Create Documents Table and Match Function",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Telegram Trigger": {
      "main": [
        [
          {
            "node": "If",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "If": {
      "main": [
        [
          {
            "node": "Edit Fields2",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Table Name",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create Document Rows Table (for Tabular Data)": {
      "main": [
        [
          {
            "node": "Insert Document Metadata",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Insert Document Metadata": {
      "main": [
        [
          {
            "node": "HTTP Request2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send a text message": {
      "main": [
        []
      ]
    },
    "Edit Fields1": {
      "main": [
        [
          {
            "node": "AI Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Edit Fields2": {
      "main": [
        [
          {
            "node": "AI Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Google Gemini Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "AI Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Postgres Chat Memory": {
      "ai_memory": [
        [
          {
            "node": "AI Agent",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "AI Agent": {
      "main": [
        [
          {
            "node": "Send a text message1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Embeddings Google Gemini": {
      "ai_embedding": [
        [
          {
            "node": "PGVector Store",
            "type": "ai_embedding",
            "index": 0
          }
        ]
      ]
    },
    "PGVector Store": {
      "ai_tool": [
        [
          {
            "node": "AI Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "searchTableName": {
      "ai_tool": [
        [
          {
            "node": "AI Agent",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "Table Name DELETE": {
      "main": [
        [
          {
            "node": "DELETE Documents Table and Match Function",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "When clicking ‚ÄòExecute workflow‚Äô": {
      "main": [
        [
          {
            "node": "Table Name DELETE",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "createdAt": "2025-06-13T03:39:21.763Z",
  "id": "zJwCFMqgZ3rV1Tl2",
  "isArchived": false,
  "meta": {
    "templateCredsSetupCompleted": true
  },
  "name": "Documentation Agent",
  "nodes": [
    {
      "parameters": {
        "url": "={{ $('Table Name').item.json.url }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        696,
        -680
      ],
      "id": "c72ffa12-fa84-4752-9df7-d05fca0c227f",
      "name": "HTTP Request2"
    },
    {
      "parameters": {
        "jsCode": "// --- CONFIGURACI√ìN ---\n// Define el dominio principal para filtrar enlaces externos.\n// Cambia esto por el dominio del sitio que est√°s analizando.\nconst MAIN_DOMAIN = 'tailwindcss.com';\n// --------------------\n\nconst htmlString = $input.first().json.data;\n\n// Paso 1: Eliminar etiquetas no deseadas (sin cambios)\nconst cleanedHtml = htmlString\n  .replace(/<script[\\s\\S]*?<\\/script>/gi, '')\n  .replace(/<style[\\s\\S]*?<\\/style>/gi, '')\n  .replace(/<head[\\s\\S]*?<\\/head>/gi, '')\n  .replace(/<noscript[\\s\\S]*?<\\/noscript>/gi, '')\n  .replace(/<meta[^>]*>/gi, '')\n  .replace(/<link[^>]*>/gi, '')\n  .replace(/<svg[\\s\\S]*?<\\/svg>/gi, '')\n  .replace(/<[^>]+>/g, '\\n'); // Quita todas las etiquetas restantes, dejando texto plano\n\n// Paso 2: Extraer texto plano limpio (sin cambios)\nconst plainText = cleanedHtml\n  .replace(/\\n\\s*\\n/g, '\\n')  // Quita l√≠neas vac√≠as m√∫ltiples\n  .replace(/\\s{2,}/g, ' ')    // Espacios m√∫ltiples -> uno\n  .replace(/^\\s+|\\s+$/g, '')  // Quita espacios iniciales/finales\n  .trim();\n\n// Paso 3: Extraer y FILTRAR enlaces v√°lidos\nconst urlRegex = /<a[^>]*href=[\"']([^\"']+)[\"'][^>]*>(.*?)<\\/a>/gi;\n\n// Funci√≥n para excluir archivos, anclas y protocolos especiales\nconst isFileOrSpecialLink = (url) => {\n  const excludeExtensions = [\n    '.jpg', '.jpeg', '.png', '.gif', '.svg', '.webp',\n    '.pdf', '.doc', '.docx', '.xls', '.xlsx', '.zip', '.rar', '.csv', '.woff2', '.ttf'\n  ];\n  const lower = url.toLowerCase();\n  return (\n    lower.startsWith('#') ||\n    lower.startsWith('javascript:') ||\n    lower.startsWith('mailto:') ||\n    lower.startsWith('tel:') ||\n    excludeExtensions.some(ext => lower.endsWith(ext)) // Usamos endsWith para mayor precisi√≥n\n  );\n};\n\n// NUEVA FUNCI√ìN: Verifica si un enlace es interno al dominio principal\nconst isInternalLink = (url, baseDomain) => {\n  // Si empieza con '/', es una ruta relativa del mismo sitio (ej: /docs/installation) -> V√ÅLIDO\n  if (url.startsWith('/')) {\n    return true;\n  }\n  \n  try {\n    // Intentamos crear un objeto URL para analizarlo\n    const parsedUrl = new URL(url);\n    // Si el hostname termina con nuestro dominio principal (ej: blog.tailwindcss.com) -> V√ÅLIDO\n    return parsedUrl.hostname.endsWith(baseDomain);\n  } catch (e) {\n    // Si no es una URL v√°lida (ej: un texto cualquiera), lo descartamos\n    return false;\n  }\n};\n\nconst matches = [...htmlString.matchAll(urlRegex)];\nconst urls = matches\n  .map(([_, href, text]) => ({ nombre: text.trim(), url: href.trim() }))\n  .filter(link =>\n    link.url &&\n    link.nombre &&\n    !isFileOrSpecialLink(link.url) && // Mantiene el filtro original\n    isInternalLink(link.url, MAIN_DOMAIN) // A√ëADE el nuevo filtro de dominio\n  );\n\nreturn [\n  {\n    json: {\n      contenido: plainText,\n      urls\n    }\n  }\n];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        916,
        -680
      ],
      "id": "b41efa80-12bc-4c33-a1d8-bb91afe43920",
      "name": "Code2"
    },
    {
      "parameters": {
        "jsCode": "/*\n  Este nodo prepara todo para empezar.\n  Crea un 'estado' inicial que se pasar√° a trav√©s del flujo.\n*/\n\nconst startUrl = 'https://tailwindcss.com/docs';\nconst urls = $input.first().json.urls.map((url) => {\n  return `https://tailwindcss.com${url.url}`\n})\n\nconst initialState = {\n  // La lista de URLs que faltan por visitar (nuestra cola de trabajo)\n  urls_to_visit: [startUrl, ...urls],\n  \n  // Un array de URLs que ya hemos procesado para no repetirlas\n  visited_urls: [], // <-- ESTE ES EL CAMBIO M√ÅS IMPORTANTE\n  \n  // Aqu√≠ guardaremos todo el contenido que extraigamos\n  all_content: [],\n\n  // La URL que estamos procesando en la iteraci√≥n actual\n  current_url: null\n};\n\nreturn initialState;"
      },
      "name": "1. Initialize State1",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1136,
        -680
      ],
      "id": "fc921187-c6e6-461e-86c9-511bd3223d96"
    },
    {
      "parameters": {
        "jsCode": "/*\n  Este nodo act√∫a como el gestor de la cola.\n  1. Toma la siguiente URL de la lista 'urls_to_visit'.\n  2. La elimina de la cola.\n  3. La a√±ade a la lista 'visited_urls' para no volver a procesarla.\n  4. Pasa la URL actual al siguiente nodo para la petici√≥n HTTP.\n*/\n\nconst state = $input.first().json;\n\n// Sacamos la primera URL de la cola de trabajo\nconst nextUrl = state.urls_to_visit.shift();\n\n// La a√±adimos al registro de visitadas (usando .push() para el array)\nstate.visited_urls.push(nextUrl);\n\n// La establecemos como la URL actual para esta iteraci√≥n\nstate.current_url = nextUrl;\n\nreturn state;\n"
      },
      "name": "3. Get Next URL from Queue1",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1356,
        -680
      ],
      "id": "55a7c213-7205-4fea-a5cb-16a20459cb0f"
    },
    {
      "parameters": {
        "url": "={{ $json.current_url }}",
        "options": {
          "response": {}
        }
      },
      "name": "4. HTTP Request1",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        1576,
        -855
      ],
      "id": "812cde99-5b00-4f22-a1b9-da0ca9cc2b1c"
    },
    {
      "parameters": {
        "jsCode": "/*\n  Este es el coraz√≥n del scraper.\n  Procesa, extrae contenido y encuentra nuevos links.\n*/\n\n// FUNCI√ìN DE NORMALIZACI√ìN\nconst normalizeUrl = (urlString) => {\n  if (!urlString) return null;\n  try {\n    const url = new URL(urlString);\n    url.hash = ''; // Elimina anclas (#...)\n\n    // Reconstruir sin query ni hash\n    let href = url.origin + url.pathname;\n\n    // Eliminar barra final incluso si pathname es '/'\n    if (href !== url.origin && href.endsWith('/')) {\n      href = href.slice(0, -1);\n    }\n\n    // Si ten√≠a query params, los volvemos a incluir ordenados (opcional)\n    if (url.search) {\n      href += url.search;\n    }\n\n    return href;\n  } catch (e) {\n    return null;\n  }\n};\n\n// Leemos estado del nodo anterior\nconst state = $items(\"3. Get Next URL from Queue1\")[0].json;\n\n// HTML recibido\nconst htmlString = $input.first().json.data;\n\nif (!htmlString) return state;\n\n// --- LIMPIEZA DEL CONTENIDO ---\nconst cleanedHtml = htmlString\n  .replace(/<script[\\s\\S]*?<\\/script>/gi, '')\n  .replace(/<style[\\s\\S]*?<\\/style>/gi, '')\n  .replace(/<head[\\s\\S]*?<\\/head>/gi, '')\n  .replace(/<nav[\\s\\S]*?<\\/nav>/gi, '')\n  .replace(/<header[\\s\\S]*?<\\/header>/gi, '')\n  .replace(/<footer[\\s\\S]*?<\\/footer>/gi, '')\n  .replace(/<svg[\\s\\S]*?<\\/svg>/gi, '')\n  .replace(/<[^>]+>/g, '\\n');\n\nconst plainText = cleanedHtml\n  .replace(/\\n\\s*\\n/g, '\\n')\n  .replace(/\\s{2,}/g, ' ')\n  .trim();\n\nstate.all_content.push({\n  source: state.current_url,\n  content: plainText,\n});\n\n// --- EXTRACCI√ìN Y FILTRADO DE ENLACES ---\nconst BASE_URL = 'https://tailwindcss.com/docs';\nconst urlRegex = /<a[^>]*href=[\"']([^\"']+)[\"'][^>]*>/gi;\nconst matches = [...htmlString.matchAll(urlRegex)];\n\nconst excludeExtensions = ['.jpg', '.png', '.gif', '.zip', '.pdf', '.svg', '.ico', '.webp'];\n\nconst newLinksSet = new Set(); // Para evitar duplicados\n\nfor (const [, href] of matches) {\n  if (!href) continue;\n  try {\n    const fullUrl = new URL(href, BASE_URL).href;\n    const normalized = normalizeUrl(fullUrl);\n    if (\n      normalized &&\n      normalized.startsWith(BASE_URL) &&\n      !excludeExtensions.some(ext => normalized.toLowerCase().endsWith(ext)) &&\n      !state.visited_urls.includes(normalized)\n    ) {\n      newLinksSet.add(normalized);\n    }\n  } catch (e) {\n    continue; // URL inv√°lida, se ignora\n  }\n}\n\n// Unir las nuevas URLs con las que ya est√°n en la cola, eliminando duplicados\nconst combinedUrls = [...state.urls_to_visit, ...newLinksSet];\nconst uniqueUrlsToVisit = [...new Set(combinedUrls)];\n\n// Filtramos por si alguna ya fue visitada (por seguridad)\nstate.urls_to_visit = uniqueUrlsToVisit.filter(url => !state.visited_urls.includes(url));\n\nreturn state;\n"
      },
      "name": "5. Extract Content & Find New Links1",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1796,
        -855
      ],
      "id": "88efe2a7-82be-4bf7-953a-f9efb8586ca6"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "2ac4b4dd-91ef-4a72-9edc-9e1578b731fd",
              "name": "Url",
              "value": "={{ $json.all_content[0].source }}",
              "type": "string"
            },
            {
              "id": "7ec1af15-21f2-4412-a736-62442e97b9b5",
              "name": "Content",
              "value": "={{ $json.all_content[0].content }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        2016,
        -855
      ],
      "id": "f7a17c7a-a765-4631-8c5c-98a3637052d9",
      "name": "Edit Fields"
    },
    {
      "parameters": {
        "jsCode": "// Loop over input items and add a new field called 'myNewField' to the JSON of each one\nconst state = $('5. Extract Content & Find New Links1').first().json;\n\nif ($('5. Extract Content & Find New Links1').first().json.all_content[0]) {\n  state.all_content = [];\n}\n\nreturn state;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2732,
        -855
      ],
      "id": "6a315a35-014e-4f44-977c-1e1c56d3f85c",
      "name": "Code4"
    },
    {
      "parameters": {
        "model": "text-embedding-3-small",
        "options": {}
      },
      "id": "911de3db-e9aa-4032-b278-d0e8fb3a61a6",
      "name": "Embeddings OpenAI1",
      "type": "@n8n/n8n-nodes-langchain.embeddingsOpenAi",
      "typeVersion": 1,
      "position": [
        2236,
        -635
      ],
      "credentials": {
        "openAiApi": {
          "id": "UYsXoFpwT6Oh1GeF",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "options": {}
      },
      "id": "def5c467-e949-4660-91b4-10221e4f6329",
      "name": "Recursive Character Text Splitter",
      "type": "@n8n/n8n-nodes-langchain.textSplitterRecursiveCharacterTextSplitter",
      "typeVersion": 1,
      "position": [
        2444,
        -435
      ]
    },
    {
      "parameters": {
        "jsonMode": "expressionData",
        "jsonData": "={{ $json.Content }}",
        "options": {
          "metadata": {
            "metadataValues": [
              {
                "name": "file_id",
                "value": "={{ $json.Url }}"
              }
            ]
          }
        }
      },
      "id": "f30fcda5-c22d-43b0-adef-241a413d8e3a",
      "name": "Default Data Loader1",
      "type": "@n8n/n8n-nodes-langchain.documentDefaultDataLoader",
      "typeVersion": 1,
      "position": [
        2356,
        -632.5
      ]
    },
    {
      "parameters": {
        "conditions": {
          "number": [
            {
              "value1": "={{ $json.urls_to_visit.length }}",
              "operation": "larger"
            }
          ]
        }
      },
      "name": "2. Is Queue Empty?1",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        2952,
        -680
      ],
      "id": "daac1730-7b8b-4c8a-8b86-ab671cc5f69c"
    },
    {
      "parameters": {
        "mode": "insert",
        "tableName": "tailwind_documentations",
        "options": {
          "columnNames": {
            "values": {
              "contentColumnName": "content"
            }
          }
        }
      },
      "type": "@n8n/n8n-nodes-langchain.vectorStorePGVector",
      "typeVersion": 1.3,
      "position": [
        2252,
        -855
      ],
      "id": "750f37d9-bddb-4c97-8437-22bb188c9112",
      "name": "Postgres PGVector Store",
      "credentials": {
        "postgres": {
          "id": "gFhB2sfDoFHEQ7Pn",
          "name": "pgvector n8n_scrapper"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "CREATE TABLE {{ $('Table Name').item.json.tableName }}_metadata (\n    id TEXT PRIMARY KEY,\n    title TEXT,\n    url TEXT,\n    created_at TIMESTAMP DEFAULT NOW(),\n    schema TEXT\n);",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        -222,
        -680
      ],
      "id": "e0a16c98-35e7-4833-a7aa-5f9aaa5ed169",
      "name": "Create Document Metadata Table",
      "credentials": {
        "postgres": {
          "id": "gFhB2sfDoFHEQ7Pn",
          "name": "pgvector n8n_scrapper"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "CREATE TABLE {{ $('Table Name').item.json.tableName }}_rows (\n    id SERIAL PRIMARY KEY,\n    dataset_id TEXT REFERENCES {{ $('Table Name').item.json.tableName }}_metadata(id),\n    row_data JSONB  -- Store the actual row data\n);",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        256,
        -680
      ],
      "id": "aae807cb-7ffe-48ea-b3ec-b06b3e9caf5e",
      "name": "Create Document Rows Table (for Tabular Data)",
      "credentials": {
        "postgres": {
          "id": "gFhB2sfDoFHEQ7Pn",
          "name": "pgvector n8n_scrapper"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- Enable the pgvector extension to work with embedding vectors\n--create extension vector; --Ya esta activo\n\n-- Create a table to store your documents\ncreate table {{ $('Table Name').item.json.tableName }} (\n  id bigserial primary key,\n  content text, -- corresponds to Document.pageContent\n  metadata jsonb, -- corresponds to Document.metadata\n  embedding vector(1536) -- 1536 works for OpenAI embeddings, change if needed\n);\n\n-- Create a function to search for documents\ncreate function match_{{ $('Table Name').item.json.tableName }}(\n  query_embedding vector(1536),\n  match_count int default null,\n  filter jsonb DEFAULT '{}'\n) returns table (\n  id bigint,\n  content text,\n  metadata jsonb,\n  similarity float\n)\nlanguage plpgsql\nas $$\n#variable_conflict use_column\nbegin\n  return query\n  select\n    id,\n    content,\n    metadata,\n    1 - ({{ $('Table Name').item.json.tableName }}.embedding <=> query_embedding) as similarity\n  from {{ $json.tableName }}\n  where metadata @> filter\n  order by {{ $('Table Name').item.json.tableName }}.embedding <=> query_embedding\n  limit match_count;\nend;\n$$;",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        -700,
        -680
      ],
      "id": "65412e9e-8670-4d92-abdc-92db00643381",
      "name": "Create Documents Table and Match Function",
      "alwaysOutputData": false,
      "credentials": {
        "postgres": {
          "id": "gFhB2sfDoFHEQ7Pn",
          "name": "pgvector n8n_scrapper"
        }
      }
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "2b5fa507-cd73-4fd9-a388-dafb81269682",
              "name": "message",
              "value": "={{ $json.message.text }}",
              "type": "string"
            },
            {
              "id": "4abdbb12-2f86-4a2f-a650-45b3851ebd92",
              "name": "url",
              "value": "={{ $json.message.text.extractUrl() }}",
              "type": "string"
            },
            {
              "id": "315bc723-45e0-4644-96b1-81366f5c6d31",
              "name": "=tableName",
              "value": "={{ $json.message.text.extractUrl().extractDomain().split('.')[0] }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -1360,
        -780
      ],
      "id": "4d03b177-9ab9-4645-a02f-b9a8ae62710f",
      "name": "Table Name"
    },
    {
      "parameters": {
        "operation": "upsert",
        "schema": {
          "__rl": true,
          "mode": "list",
          "value": "public"
        },
        "table": {
          "__rl": true,
          "value": "={{ $('Table Name').item.json.tableName }}_metadata",
          "mode": "name"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "id": "={{ $('Table Name').item.json.url }}",
            "url": "={{ $('Table Name').item.json.url }}",
            "title": "={{ $('Table Name').item.json.tableName }}"
          },
          "matchingColumns": [
            "id"
          ],
          "schema": [
            {
              "id": "id",
              "displayName": "id",
              "required": true,
              "defaultMatch": true,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": true,
              "removed": false
            },
            {
              "id": "title",
              "displayName": "title",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": false
            },
            {
              "id": "url",
              "displayName": "url",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": false
            },
            {
              "id": "created_at",
              "displayName": "created_at",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "dateTime",
              "canBeUsedToMatch": false
            },
            {
              "id": "schema",
              "displayName": "schema",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "canBeUsedToMatch": false,
              "removed": true
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        476,
        -680
      ],
      "id": "0294309e-940b-4e1c-8a21-df3e10c4beb5",
      "name": "Insert Document Metadata",
      "executeOnce": true,
      "credentials": {
        "postgres": {
          "id": "gFhB2sfDoFHEQ7Pn",
          "name": "pgvector n8n_scrapper"
        }
      }
    },
    {
      "parameters": {
        "updates": [
          "message"
        ],
        "additionalFields": {}
      },
      "type": "n8n-nodes-base.telegramTrigger",
      "typeVersion": 1.2,
      "position": [
        -1800,
        -880
      ],
      "id": "c0391082-ada3-409f-b96e-45bca27dc723",
      "name": "Telegram Trigger",
      "webhookId": "ce32e5c3-6eab-4e57-a34d-c42cde4f3313",
      "credentials": {
        "telegramApi": {
          "id": "O9mvGRSt0wAuuL8T",
          "name": "LinkSeeker"
        }
      },
      "disabled": true
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT EXISTS (\n  SELECT FROM information_schema.tables \n  WHERE table_schema = 'public' \n    AND table_name = '{{ $json.tableName }}'\n);\n",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        -1140,
        -780
      ],
      "id": "f78a13bd-ecc2-4175-b924-64f4a3c3e337",
      "name": "search Table name",
      "credentials": {
        "postgres": {
          "id": "gFhB2sfDoFHEQ7Pn",
          "name": "pgvector n8n_scrapper"
        }
      }
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "7051fee8-02e2-4f0c-8d5a-f3bd091eca69",
              "leftValue": "={{ $json.exists }}",
              "rightValue": "true",
              "operator": {
                "type": "boolean",
                "operation": "true",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -920,
        -780
      ],
      "id": "7d38dfee-ada5-4214-b0ee-90241ffd1f79",
      "name": "Table exist"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 2
          },
          "conditions": [
            {
              "id": "8f54308d-2a32-49ba-aebd-ec9144ac453d",
              "leftValue": "={{ $json.message.text.extractUrl() }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notExists",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.2,
      "position": [
        -1580,
        -880
      ],
      "id": "6e34e829-8155-4ffa-8324-1cc55d795107",
      "name": "If"
    },
    {
      "parameters": {
        "chatId": "={{ $('Telegram Trigger').item.json.message.from.id }}",
        "text": "=‚ú®üìö **¬°Tu documentaci√≥n ya est√° lista!** üöÄ\n\nHola üëã, buenas noticias: hemos cargado correctamente la documentaci√≥n que solicitaste.\nAhora puedes consultarla directamente aqu√≠ üß†üí¨\n\nüîç Solo escribe tus preguntas como:\n\n* ‚Äú¬øC√≥mo se configura el modo oscuro?‚Äù\n* ‚ÄúMu√©strame un ejemplo de autenticaci√≥n‚Äù\n* ‚Äú¬øQu√© errores comunes hay?‚Äù\n\nEstamos listos para ayudarte a explorarla con facilidad y precisi√≥n ü§ìüìñ\n\nSi necesitas otra documentaci√≥n, tambi√©n puedes compartirnos el enlace oficial para agregarla.\n\n¬°Vamos a por ello! üí°üôå",
        "additionalFields": {}
      },
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [
        3172,
        -680
      ],
      "id": "0e79920b-ae10-4a44-a5f2-de90fdceb779",
      "name": "Send a text message",
      "webhookId": "a391d488-652d-4e4e-a215-32b1006a1e8a",
      "credentials": {
        "telegramApi": {
          "id": "O9mvGRSt0wAuuL8T",
          "name": "LinkSeeker"
        }
      }
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "0e884815-856f-49f7-91f1-67980c2c4e95",
              "name": "prompt.user",
              "value": "=user_name: {{ $('Telegram Trigger').item.json.message.from.first_name }},\n\ntableName: {{ $('Table Name').item.json.tableName }},\n\nmessage: {{ $('Table Name').item.json.message.replace(/https?:\\/\\/(?:www\\.)?([^\\/\\s]+)/g, '$1').replace(/\\.com|\\.org|\\.io|\\.dev|\\.net|\\.co/gi, '').replace(/\\/.*/g, '').replace('enlace','').replace('url','') }}\n",
              "type": "string"
            },
            {
              "id": "c6d4f18b-bc68-4a86-8d05-be94948607e4",
              "name": "prompt.system",
              "value": "=  Eres un agente experto en documentaci√≥n t√©cnica. Tu misi√≥n es asistir a desarrolladores y usuarios t√©cnicos a consultar, buscar y entender documentaci√≥n sobre tecnolog√≠as espec√≠ficas, frameworks, librer√≠as, herramientas o estructuras personalizadas.\n\n  Puedes acceder a:\n  - Una base de vectores (PGVector) con fragmentos de documentaci√≥n, organizados en tablas. Cada tabla representa una documentaci√≥n distinta.\n  - Una herramienta searchTableName que te permite buscar los nombres de todas las tablas disponibles para determinar qu√© documentaciones est√°n cargadas.\n\n  Tu objetivo es ayudar al usuario a encontrar y explorar documentaci√≥n almacenada en el sistema, de forma conversacional y precisa.\n\n  --- üß† Flujo general de razonamiento ---\n\n  1. Si el usuario ya mencion√≥ la tecnolog√≠a o documentaci√≥n (por ejemplo, \"Tailwind\", \"NextAuth\", \"Stripe API\") y sabes qu√© tabla contiene esa documentaci√≥n, puedes usar directamente la herramienta `PGVector Retrieval`.\n\n  2. Si **no conoces a√∫n el `tableName`**:\n     - Ejecuta la herramienta `searchTableName` para obtener todos los nombres de tablas disponibles.\n     - Analiza los nombres y as√≥cialos con las palabras clave que el usuario mencion√≥.\n     - Si encuentras una tabla relevante, guarda ese nombre como `tableName` y √∫salo para la herramienta PGVector.\n     - Si no hay coincidencias, informa al usuario que no tienes esa documentaci√≥n y solicita el enlace a la **documentaci√≥n oficial** (no el sitio principal, sino la URL de la documentaci√≥n t√©cnica).\n\n  3. Mant√©n el contexto:\n     - Si el usuario ya est√° consultando una documentaci√≥n, no preguntes otra vez qu√© documentaci√≥n desea.\n     - Usa `tableName` activamente mientras est√© en contexto.\n     - Si el usuario cambia de tema o tecnolog√≠a, analiza y reinicia el flujo seg√∫n corresponda.\n\n  4. Puedes responder preguntas espec√≠ficas sobre secciones de la documentaci√≥n (como instalaci√≥n, configuraci√≥n, autenticaci√≥n, errores comunes, ejemplos, etc.) bas√°ndote en los fragmentos obtenidos por PGVector.\n\n  5. Si el usuario solicita documentaci√≥n que **a√∫n no est√° cargada**, responde amablemente:\n     - \"Actualmente no contamos con documentaci√≥n sobre [tecnolog√≠a mencionada].\"\n     - Pide que proporcione la URL directa de la documentaci√≥n t√©cnica para poder agregarla al sistema.\n     - Informa que una vez cargada, podr√° consultarla aqu√≠.\n\n  --- üß∞ Instrucciones de uso de herramientas ---\n\n  Tool: **searchTableName**\n  - Uso: Cuando el `tableName` a√∫n no ha sido identificado.\n  - No requiere par√°metros.\n  - Devuelve una lista de todas las tablas disponibles.\n  - Acci√≥n esperada: Analiza los nombres y determina cu√°l coincide mejor con el t√©rmino o tecnolog√≠a mencionada por el usuario.\n  - Guarda el nombre de la tabla como `tableName`.\n\n  Tool: **PGVector Retrieval (As Tool for AI Agent)**\n  - Uso: Solo cuando ya tienes definido un `tableName`.\n  - Par√°metros:\n    - `tableName`: nombre exacto de la tabla donde est√° almacenada la documentaci√≥n.\n  - El texto actual del usuario se utiliza autom√°ticamente como `query` sem√°ntico para buscar en la documentaci√≥n.\n  - Solo debes pasar el `tableName`. No es necesario pasar el query.\n  - Por ejemplo:\n    - Usuario: \"¬øC√≥mo configuro dark mode en Tailwind?\"\n    - Acci√≥n: Si `tableName = tailwindcss`, llama a PGVector con ese nombre.\n\n  --- üîÅ Ejemplos de interacci√≥n ---\n\n  Usuario: \"¬øTienen documentaci√≥n de Tailwind?\"\n  üîπ Acci√≥n: Llama a `searchTableName`, encuentra la tabla `tailwindcss`, guarda como `tableName`, y luego usa PGVector con ese tableName.\n\n  Usuario: \"Mu√©strame c√≥mo configurar autenticaci√≥n en NextAuth\"\n  üîπ Acci√≥n: Verifica si ya est√°s trabajando con la documentaci√≥n de `nextauth`. Si no, usa `searchTableName`, encuentra `nextauth`, y luego consulta esa tabla en PGVector.\n\n  Usuario: \"¬øTienen algo de Supabase?\"\n  üîπ Acci√≥n: Si `searchTableName` no devuelve ninguna tabla relevante, responde que no hay documentaci√≥n cargada. Pide la URL directa de la documentaci√≥n oficial.\n\n  Usuario: \"¬øQu√© dice sobre los breakpoints?\"\n  üîπ Acci√≥n: Si el `tableName` actual es `tailwindcss`, usa PGVector con ese nombre y deja que la pregunta fluya como query.\n\n  --- ‚úÖ Reglas finales ---\n\n  - Nunca llames PGVector sin un `tableName`.\n  - Nunca pidas al usuario el nombre de la tabla, solo analiza o busca con `searchTableName`.\n  - Si no encuentras tabla coincidente, gu√≠a amablemente al usuario para enviar la URL de la documentaci√≥n oficial.\n  - Siempre responde con claridad y sin tecnicismos innecesarios.\n  - Mant√©n la conversaci√≥n centrada en ayudar a explorar la documentaci√≥n cargada.\n\n--- üîÅ Encadenamiento de herramientas\n\nAntes de responder al usuario:\n\n- Si necesitas identificar el `tableName`, **primero ejecuta `searchTableName`**.\n- Luego analiza los resultados, guarda el `tableName`, y sin responder a√∫n...\n- **Ejecuta directamente `PGVector Retrieval` con ese `tableName`.**\n- Solo despu√©s de haber ejecutado todas las herramientas necesarias, responde con el contenido solicitado.\n- No respondas con frases como: ‚ÄúVoy a buscar...‚Äù, ‚ÄúConsultando...‚Äù, ‚ÄúUsar√© la herramienta...‚Äù.\n- Solo responde con resultados √∫tiles y directos, como fragmentos de documentaci√≥n o respuestas concretas.",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -700,
        -980
      ],
      "id": "5957dbb9-7ef6-46ce-8f82-1b91aa28bb27",
      "name": "Edit Fields1"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "81371960-eb65-47dd-8ae1-cf6258075725",
              "name": "prompt.user",
              "value": "=\nuser_name: {{ $('Telegram Trigger').item.json.message.from.first_name }},\n\nmessage: {{ $('Telegram Trigger').item.json.message.text }}",
              "type": "string"
            },
            {
              "id": "ff0a80e2-8914-4d97-bc7c-8eec215b1597",
              "name": "prompt.system",
              "value": "=  Eres un agente experto en documentaci√≥n t√©cnica. Tu misi√≥n es asistir a desarrolladores y usuarios t√©cnicos a consultar, buscar y entender documentaci√≥n sobre tecnolog√≠as espec√≠ficas, frameworks, librer√≠as, herramientas o estructuras personalizadas.\n\n  Puedes acceder a:\n  - Una base de vectores (PGVector) con fragmentos de documentaci√≥n, organizados en tablas. Cada tabla representa una documentaci√≥n distinta.\n  - Una herramienta searchTableName que te permite buscar los nombres de todas las tablas disponibles para determinar qu√© documentaciones est√°n cargadas.\n\n  Tu objetivo es ayudar al usuario a encontrar y explorar documentaci√≥n almacenada en el sistema, de forma conversacional y precisa.\n\n  --- üß† Flujo general de razonamiento ---\n\n  1. Si el usuario ya mencion√≥ la tecnolog√≠a o documentaci√≥n (por ejemplo, \"Tailwind\", \"NextAuth\", \"Stripe API\") y sabes qu√© tabla contiene esa documentaci√≥n, puedes usar directamente la herramienta `PGVector Retrieval`.\n\n  2. Si **no conoces a√∫n el `tableName`**:\n     - Ejecuta la herramienta `searchTableName` para obtener todos los nombres de tablas disponibles.\n     - Analiza los nombres y as√≥cialos con las palabras clave que el usuario mencion√≥.\n     - Si encuentras una tabla relevante, guarda ese nombre como `tableName` y √∫salo para la herramienta PGVector.\n     - Si no hay coincidencias, informa al usuario que no tienes esa documentaci√≥n y solicita el enlace a la **documentaci√≥n oficial** (no el sitio principal, sino la URL de la documentaci√≥n t√©cnica).\n\n  3. Mant√©n el contexto:\n     - Si el usuario ya est√° consultando una documentaci√≥n, no preguntes otra vez qu√© documentaci√≥n desea.\n     - Usa `tableName` activamente mientras est√© en contexto.\n     - Si el usuario cambia de tema o tecnolog√≠a, analiza y reinicia el flujo seg√∫n corresponda.\n\n  4. Puedes responder preguntas espec√≠ficas sobre secciones de la documentaci√≥n (como instalaci√≥n, configuraci√≥n, autenticaci√≥n, errores comunes, ejemplos, etc.) bas√°ndote en los fragmentos obtenidos por PGVector.\n\n  5. Si el usuario solicita documentaci√≥n que **a√∫n no est√° cargada**, responde amablemente:\n     - \"Actualmente no contamos con documentaci√≥n sobre [tecnolog√≠a mencionada].\"\n     - Pide que proporcione la URL directa de la documentaci√≥n t√©cnica para poder agregarla al sistema.\n     - Informa que una vez cargada, podr√° consultarla aqu√≠.\n\n  --- üß∞ Instrucciones de uso de herramientas ---\n\n  Tool: **searchTableName**\n  - Uso: Cuando el `tableName` a√∫n no ha sido identificado.\n  - No requiere par√°metros.\n  - Devuelve una lista de todas las tablas disponibles.\n  - Acci√≥n esperada: Analiza los nombres y determina cu√°l coincide mejor con el t√©rmino o tecnolog√≠a mencionada por el usuario.\n  - Guarda el nombre de la tabla como `tableName`.\n\n  Tool: **PGVector Retrieval (As Tool for AI Agent)**\n  - Uso: Solo cuando ya tienes definido un `tableName`.\n  - Par√°metros:\n    - `tableName`: nombre exacto de la tabla donde est√° almacenada la documentaci√≥n.\n  - El texto actual del usuario se utiliza autom√°ticamente como `query` sem√°ntico para buscar en la documentaci√≥n.\n  - Solo debes pasar el `tableName`. No es necesario pasar el query.\n  - Por ejemplo:\n    - Usuario: \"¬øC√≥mo configuro dark mode en Tailwind?\"\n    - Acci√≥n: Si `tableName = tailwindcss`, llama a PGVector con ese nombre.\n\n  --- üîÅ Ejemplos de interacci√≥n ---\n\n  Usuario: \"¬øTienen documentaci√≥n de Tailwind?\"\n  üîπ Acci√≥n: Llama a `searchTableName`, encuentra la tabla `tailwindcss`, guarda como `tableName`, y luego usa PGVector con ese tableName.\n\n  Usuario: \"Mu√©strame c√≥mo configurar autenticaci√≥n en NextAuth\"\n  üîπ Acci√≥n: Verifica si ya est√°s trabajando con la documentaci√≥n de `nextauth`. Si no, usa `searchTableName`, encuentra `nextauth`, y luego consulta esa tabla en PGVector.\n\n  Usuario: \"¬øTienen algo de Supabase?\"\n  üîπ Acci√≥n: Si `searchTableName` no devuelve ninguna tabla relevante, responde que no hay documentaci√≥n cargada. Pide la URL directa de la documentaci√≥n oficial.\n\n  Usuario: \"¬øQu√© dice sobre los breakpoints?\"\n  üîπ Acci√≥n: Si el `tableName` actual es `tailwindcss`, usa PGVector con ese nombre y deja que la pregunta fluya como query.\n\n  --- ‚úÖ Reglas finales ---\n\n  - Nunca llames PGVector sin un `tableName`.\n  - Nunca pidas al usuario el nombre de la tabla, solo analiza o busca con `searchTableName`.\n  - Si no encuentras tabla coincidente, gu√≠a amablemente al usuario para enviar la URL de la documentaci√≥n oficial.\n  - Siempre responde con claridad y sin tecnicismos innecesarios.\n  - Mant√©n la conversaci√≥n centrada en ayudar a explorar la documentaci√≥n cargada.\n\n--- üîÅ Encadenamiento de herramientas\n\nAntes de responder al usuario:\n\n- Si necesitas identificar el `tableName`, **primero ejecuta `searchTableName`**.\n- Luego analiza los resultados, guarda el `tableName`, y sin responder a√∫n...\n- **Ejecuta directamente `PGVector Retrieval` con ese `tableName`.**\n- Solo despu√©s de haber ejecutado todas las herramientas necesarias, responde con el contenido solicitado.\n- No respondas con frases como: ‚ÄúVoy a buscar...‚Äù, ‚ÄúConsultando...‚Äù, ‚ÄúUsar√© la herramienta...‚Äù.\n- Solo responde con resultados √∫tiles y directos, como fragmentos de documentaci√≥n o respuestas concretas.\n\n\n\n",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -700,
        -1180
      ],
      "id": "1e705b95-d695-42fa-85c2-6189280e9f69",
      "name": "Edit Fields2"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.prompt.user }}",
        "options": {
          "systemMessage": "={{ $json.prompt.system }}"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2,
      "position": [
        -344,
        -1280
      ],
      "id": "c6813e95-a39c-4363-8349-481b497d1116",
      "name": "AI Agent"
    },
    {
      "parameters": {
        "modelName": "models/gemini-2.0-flash-thinking-exp-1219",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatGoogleGemini",
      "typeVersion": 1,
      "position": [
        -480,
        -1060
      ],
      "id": "2780d847-a1c9-4aa8-bc9c-e5accf1f840e",
      "name": "Google Gemini Chat Model",
      "credentials": {
        "googlePalmApi": {
          "id": "jQiccHfpS9BFKE4C",
          "name": "Google Gemini(PaLM) Api account"
        }
      }
    },
    {
      "parameters": {
        "sessionIdType": "customKey",
        "sessionKey": "={{ $('Telegram Trigger').item.json.message.from.id }}",
        "tableName": "chat_history_scrapper",
        "contextWindowLength": 25
      },
      "type": "@n8n/n8n-nodes-langchain.memoryPostgresChat",
      "typeVersion": 1.3,
      "position": [
        -360,
        -1060
      ],
      "id": "cb536580-1d52-4918-9aef-9f1bcd016684",
      "name": "Postgres Chat Memory",
      "credentials": {
        "postgres": {
          "id": "gFhB2sfDoFHEQ7Pn",
          "name": "pgvector n8n_scrapper"
        }
      },
      "disabled": true
    },
    {
      "parameters": {
        "chatId": "={{ $('Telegram Trigger').item.json.message.from.id }}",
        "text": "={{ $json.output }}",
        "additionalFields": {
          "appendAttribution": false
        }
      },
      "type": "n8n-nodes-base.telegram",
      "typeVersion": 1.2,
      "position": [
        256,
        -1080
      ],
      "id": "cff3af67-5e8d-43c7-a6cb-b2d0523165a9",
      "name": "Send a text message1",
      "webhookId": "a391d488-652d-4e4e-a215-32b1006a1e8a",
      "credentials": {
        "telegramApi": {
          "id": "O9mvGRSt0wAuuL8T",
          "name": "LinkSeeker"
        }
      }
    },
    {
      "parameters": {
        "modelName": "models/gemini-embedding-exp-03-07"
      },
      "type": "@n8n/n8n-nodes-langchain.embeddingsGoogleGemini",
      "typeVersion": 1,
      "position": [
        -152,
        -860
      ],
      "id": "6ae9e80f-8b36-4771-ac76-2b3bd95481d1",
      "name": "Embeddings Google Gemini",
      "credentials": {
        "googlePalmApi": {
          "id": "jQiccHfpS9BFKE4C",
          "name": "Google Gemini(PaLM) Api account"
        }
      }
    },
    {
      "parameters": {
        "mode": "retrieve-as-tool",
        "toolDescription": "Use RAG to look up information in the knowledgebase whith tableName.",
        "tableName": "={{$fromAI(\"tableName\")}}",
        "options": {
          "columnNames": {
            "values": {
              "contentColumnName": "content"
            }
          }
        }
      },
      "type": "@n8n/n8n-nodes-langchain.vectorStorePGVector",
      "typeVersion": 1.3,
      "position": [
        -240,
        -1057.5
      ],
      "id": "63c58bec-db5f-4c26-8199-df79d26332a5",
      "name": "PGVector Store",
      "credentials": {
        "postgres": {
          "id": "gFhB2sfDoFHEQ7Pn",
          "name": "pgvector n8n_scrapper"
        }
      }
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "SELECT table_schema, table_name\nFROM information_schema.tables\nWHERE table_type = 'BASE TABLE'\n  AND table_schema NOT IN ('pg_catalog', 'information_schema') -- opcional, excluye esquemas del sistema\n  AND table_name NOT LIKE '%\\_metadata'\n  AND table_name NOT LIKE '%\\_rows'\n  AND table_name NOT LIKE '%\\undefined'\n  AND table_name NOT LIKE '%\\_scrapper';\n",
        "options": {}
      },
      "type": "n8n-nodes-base.postgresTool",
      "typeVersion": 2.6,
      "position": [
        56,
        -1060
      ],
      "id": "a8065a64-0fef-4db3-a8a1-e194a212e945",
      "name": "searchTableName",
      "credentials": {
        "postgres": {
          "id": "gFhB2sfDoFHEQ7Pn",
          "name": "pgvector n8n_scrapper"
        }
      }
    },
    {
      "parameters": {
        "content": "## Ejecuta estos Nodo Una Vez para eliminar las tablas configuradas, (ELIMINA TODOS LOS DATOS ALMACENADOS)",
        "height": 300,
        "width": 720,
        "color": 3
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        -1000,
        -400
      ],
      "typeVersion": 1,
      "id": "d0061d6b-7a03-47b5-bdb6-9f8669c25c0a",
      "name": "Sticky Note5"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "315bc723-45e0-4644-96b1-81366f5c6d31",
              "name": "tableName",
              "value": "tailwindcss",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        -760,
        -280
      ],
      "id": "1aaf4e0e-c86a-494d-8cec-90663c5efa19",
      "name": "Table Name DELETE"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "DROP FUNCTION IF EXISTS match_{{ $json.tableName }};\nDROP TABLE IF EXISTS {{ $json.tableName }}_rows;\nDROP TABLE IF EXISTS {{ $json.tableName }}_metadata;\nDROP TABLE IF EXISTS {{ $json.tableName }};",
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [
        -580,
        -280
      ],
      "id": "68ab090f-d11a-4960-8523-b2b702a66c17",
      "name": "DELETE Documents Table and Match Function",
      "alwaysOutputData": false,
      "credentials": {
        "postgres": {
          "id": "gFhB2sfDoFHEQ7Pn",
          "name": "pgvector n8n_scrapper"
        }
      }
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [
        -960,
        -280
      ],
      "id": "7a467a07-2c7b-4058-a148-a1c6ed7c0496",
      "name": "When clicking ‚ÄòExecute workflow‚Äô"
    },
    {
      "parameters": {
        "operation": "select",
        "schema": {
          "__rl": true,
          "mode": "list",
          "value": "public"
        },
        "table": {
          "__rl": true,
          "value": "graph_definitions",
          "mode": "list",
          "cachedResultName": "graph_definitions"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        -740,
        -40
      ],
      "id": "1e5d2c0e-3452-452e-8fb5-f5d5a73789ec",
      "name": "Select rows from a table",
      "credentials": {
        "postgres": {
          "id": "DCoXctJfby4wsUJP",
          "name": "pgvector englishTeacher"
        }
      }
    }
  ],
  "pinData": {},
  "repo_name": "flujos_n8n",
  "repo_owner": "whitelabel-ai",
  "repo_path": "Automation/",
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [],
  "triggerCount": 1,
  "updatedAt": "2025-07-03T21:27:02.548Z",
  "versionId": "d732e16e-7c29-4b8d-baf4-b2aba6bcc801"
}