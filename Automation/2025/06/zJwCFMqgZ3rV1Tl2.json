{
  "active": false,
  "connections": {
    "When clicking ‘Execute workflow’": {
      "main": [
        [
          {
            "node": "HTTP Request2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request": {
      "main": [
        [
          {
            "node": "Code",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Markdown": {
      "main": [
        []
      ]
    },
    "OpenAI Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "AI Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "AI Agent": {
      "main": [
        []
      ]
    },
    "Code": {
      "main": [
        [
          {
            "node": "Loop Over Items",
            "type": "main",
            "index": 0
          },
          {
            "node": "Code1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop Over Items": {
      "main": [
        [],
        [
          {
            "node": "HTTP Request1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request1": {
      "main": [
        [
          {
            "node": "Code3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code3": {
      "main": [
        [
          {
            "node": "Loop Over Items",
            "type": "main",
            "index": 0
          },
          {
            "node": "Code1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set Visited URLs": {
      "main": [
        []
      ]
    },
    "Filter Unvisited URLs": {
      "main": [
        [
          {
            "node": "HTTP Request3",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request2": {
      "main": [
        [
          {
            "node": "Code2",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code2": {
      "main": [
        [
          {
            "node": "1. Initialize State1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Loop Over Items1": {
      "main": [
        [],
        [
          {
            "node": "Filter Unvisited URLs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request3": {
      "main": [
        [
          {
            "node": "Code5",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code5": {
      "main": [
        [
          {
            "node": "Loop Over Items1",
            "type": "main",
            "index": 0
          },
          {
            "node": "Code4",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Initialize1": {
      "main": [
        [
          {
            "node": "Loop Over Items1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "1. Initialize State": {
      "main": [
        [
          {
            "node": "2. Is Queue Empty?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "2. Is Queue Empty?": {
      "main": [
        [
          {
            "node": "3. Get Next URL from Queue",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "6. Final Result",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "3. Get Next URL from Queue": {
      "main": [
        [
          {
            "node": "4. HTTP Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "4. HTTP Request": {
      "main": [
        [
          {
            "node": "5. Extract Content & Find New Links",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "5. Extract Content & Find New Links": {
      "main": [
        [
          {
            "node": "2. Is Queue Empty?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "1. Initialize State1": {
      "main": [
        [
          {
            "node": "2. Is Queue Empty?1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "2. Is Queue Empty?1": {
      "main": [
        [
          {
            "node": "3. Get Next URL from Queue1",
            "type": "main",
            "index": 0
          }
        ],
        []
      ]
    },
    "3. Get Next URL from Queue1": {
      "main": [
        [
          {
            "node": "4. HTTP Request1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "4. HTTP Request1": {
      "main": [
        [
          {
            "node": "5. Extract Content & Find New Links1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "5. Extract Content & Find New Links1": {
      "main": [
        [
          {
            "node": "Pinecone Vector Store",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Pinecone Vector Store": {
      "main": [
        [
          {
            "node": "2. Is Queue Empty?1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Embeddings OpenAI": {
      "ai_embedding": [
        [
          {
            "node": "Pinecone Vector Store",
            "type": "ai_embedding",
            "index": 0
          }
        ]
      ]
    },
    "Default Data Loader": {
      "ai_document": [
        [
          {
            "node": "Pinecone Vector Store",
            "type": "ai_document",
            "index": 0
          }
        ]
      ]
    },
    "Character Text Splitter": {
      "ai_textSplitter": [
        [
          {
            "node": "Default Data Loader",
            "type": "ai_textSplitter",
            "index": 0
          }
        ]
      ]
    },
    "RESULTADO FINAL": {
      "main": [
        [
          {
            "node": "Get many events",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "createdAt": "2025-06-13T03:39:21.763Z",
  "id": "zJwCFMqgZ3rV1Tl2",
  "isArchived": false,
  "meta": {
    "templateCredsSetupCompleted": true
  },
  "name": "Documentation Agent",
  "nodes": [
    {
      "parameters": {},
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [
        -820,
        -740
      ],
      "id": "23650202-0b98-47fa-a121-72e36a209b6c",
      "name": "When clicking ‘Execute workflow’"
    },
    {
      "parameters": {
        "url": "https://tailwindcss.com/docs",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        140,
        0
      ],
      "id": "51cea27e-ac39-4d7d-909b-40e17e40d2be",
      "name": "HTTP Request"
    },
    {
      "parameters": {
        "html": "={{ $json.data }}",
        "options": {}
      },
      "type": "n8n-nodes-base.markdown",
      "typeVersion": 1,
      "position": [
        240,
        420
      ],
      "id": "540dbe7e-4665-496e-b4cc-625381d41689",
      "name": "Markdown"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=Te voy a pasar el contenido HTML de una página. Quiero que me devuelvas un JSON con exactamente dos campos:\n\ncontenido: un string con solo el texto plano, es decir, sin etiquetas HTML ni Markdown, sin clases, estilos, saltos de línea innecesarios, ni bloques de código como <pre>, <code>, etc. No debe incluir URLs, imágenes, ni descripciones técnicas de estilo o scripts. El texto debe ser completamente limpio y legible.\n\nurls: un array de objetos con la estructura { nombre: string, url: string }, donde nombre es el texto del enlace y url es la dirección a la que apunta. Incluye únicamente los enlaces que apuntan a vistas navegables de páginas web.\n\n❌ No incluyas en urls:\n\nEnlaces a imágenes (por ejemplo .jpg, .png, .svg, etc.)\n\nEnlaces a archivos descargables (como .pdf, .doc, .docx, .xls, .xlsx, .zip, .rar, .csv, etc.)\n\nEnlaces vacíos o con #\n\n✅ Solo incluye URLs que lleven a otras páginas en el navegador (por ejemplo /contacto, https://ejemplo.com/info, etc.).\n\nEl JSON debe estar correctamente estructurado y no debe contener ningún texto adicional, encabezado o explicación fuera del JSON.\n\nAquí está el contenido HTML que quiero procesar:\n{{ $json.data }}",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2,
      "position": [
        780,
        420
      ],
      "id": "7cf0fa45-ae11-4093-9280-15dabffc5c2f",
      "name": "AI Agent"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "mode": "list",
          "value": "gpt-4o-mini"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        800,
        600
      ],
      "id": "b6ca7b5d-85b9-4335-bf5e-51923e2e8b4e",
      "name": "OpenAI Chat Model",
      "credentials": {
        "openAiApi": {
          "id": "UYsXoFpwT6Oh1GeF",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const htmlString = $input.first().json.data;\n\n// Paso 1: Eliminar etiquetas no deseadas\nconst cleanedHtml = htmlString\n  .replace(/<script[\\s\\S]*?<\\/script>/gi, '')\n  .replace(/<style[\\s\\S]*?<\\/style>/gi, '')\n  .replace(/<!--[\\s\\S]*?-->/g, '')\n  .replace(/<head[\\s\\S]*?<\\/head>/gi, '')\n  .replace(/<noscript[\\s\\S]*?<\\/noscript>/gi, '')\n  .replace(/<meta[^>]*>/gi, '')\n  .replace(/<link[^>]*>/gi, '')\n  .replace(/<svg[\\s\\S]*?<\\/svg>/gi, '')\n  .replace(/<[^>]+>/g, '\\n'); // Quita todas las etiquetas restantes, dejando texto plano\n\n// Paso 2: Extraer texto plano limpio\nconst plainText = cleanedHtml\n  .replace(/\\n\\s*\\n/g, '\\n')  // Quita líneas vacías múltiples\n  .replace(/\\s{2,}/g, ' ')    // Espacios múltiples -> uno\n  .replace(/^\\s+|\\s+$/g, '')  // Quita espacios iniciales/finales\n  .trim();\n\n// Paso 3: Extraer enlaces válidos\nconst urlRegex = /<a[^>]*href=[\"']([^\"']+)[\"'][^>]*>(.*?)<\\/a>/gi;\n\nconst isExcluded = (url) => {\n  const excludeExtensions = [\n    '.jpg', '.jpeg', '.png', '.gif', '.svg', '.webp',\n    '.pdf', '.doc', '.docx', '.xls', '.xlsx', '.zip', '.rar', '.csv', '.woff2', '.ttf'\n  ];\n  const lower = url.toLowerCase();\n  return (\n    lower.startsWith('#') ||\n    lower.startsWith('javascript:') ||\n    excludeExtensions.some(ext => lower.includes(ext))\n  );\n};\n\nconst matches = [...htmlString.matchAll(urlRegex)];\nconst urls = matches\n  .map(([_, href, text]) => ({ nombre: text.trim(), url: href.trim() }))\n  .filter(link => link.url && link.nombre && !isExcluded(link.url));\n\nreturn [\n  {\n    json: {\n      contenido: plainText,\n      urls\n    }\n  }\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        360,
        0
      ],
      "id": "aee1a8fb-cd9f-4221-84b0-b18b92401f72",
      "name": "Code"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        600,
        60
      ],
      "id": "8393c568-58f5-43f2-b84f-7eedce76fb67",
      "name": "Loop Over Items"
    },
    {
      "parameters": {
        "url": "=https://tailwindcss.com{{ $json.urls[0].url }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        820,
        80
      ],
      "id": "e091cbdc-27e1-490b-94c9-00a62c2334f6",
      "name": "HTTP Request1"
    },
    {
      "parameters": {
        "jsCode": "const textContent = $input.first().json.contenido\nconst originUrl =  'https://tailwindcss.com' + $input.first().json.urls[1].url\n\nreturn [{\n  json: {\n    sourceUrl: originUrl,\n    content: textContent,\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1160,
        -120
      ],
      "id": "ffd99f20-26c5-4444-9a0a-42fc52d24cda",
      "name": "Code1"
    },
    {
      "parameters": {
        "jsCode": "const htmlString = $input.first().json.data;\n\n// Paso 1: Eliminar etiquetas no deseadas\nconst cleanedHtml = htmlString\n  .replace(/<script[\\s\\S]*?<\\/script>/gi, '')\n  .replace(/<style[\\s\\S]*?<\\/style>/gi, '')\n  .replace(/<!--[\\s\\S]*?-->/g, '')\n  .replace(/<head[\\s\\S]*?<\\/head>/gi, '')\n  .replace(/<noscript[\\s\\S]*?<\\/noscript>/gi, '')\n  .replace(/<meta[^>]*>/gi, '')\n  .replace(/<link[^>]*>/gi, '')\n  .replace(/<svg[\\s\\S]*?<\\/svg>/gi, '')\n  .replace(/<[^>]+>/g, '\\n'); // Quita todas las etiquetas restantes, dejando texto plano\n\n// Paso 2: Extraer texto plano limpio\nconst plainText = cleanedHtml\n  .replace(/\\n\\s*\\n/g, '\\n')  // Quita líneas vacías múltiples\n  .replace(/\\s{2,}/g, ' ')    // Espacios múltiples -> uno\n  .replace(/^\\s+|\\s+$/g, '')  // Quita espacios iniciales/finales\n  .trim();\n\n// Paso 3: Extraer enlaces válidos\nconst urlRegex = /<a[^>]*href=[\"']([^\"']+)[\"'][^>]*>(.*?)<\\/a>/gi;\n\nconst isExcluded = (url) => {\n  const excludeExtensions = [\n    '.jpg', '.jpeg', '.png', '.gif', '.svg', '.webp',\n    '.pdf', '.doc', '.docx', '.xls', '.xlsx', '.zip', '.rar', '.csv', '.woff2', '.ttf'\n  ];\n  const lower = url.toLowerCase();\n  return (\n    lower.startsWith('#') ||\n    lower.startsWith('javascript:') ||\n    excludeExtensions.some(ext => lower.includes(ext))\n  );\n};\n\nconst matches = [...htmlString.matchAll(urlRegex)];\nconst urls = matches\n  .map(([_, href, text]) => ({ nombre: text.trim(), url: href.trim() }))\n  .filter(link => link.url && link.nombre && !isExcluded(link.url));\n\nreturn [\n  {\n    json: {\n      contenido: plainText,\n      urls\n    }\n  }\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        980,
        80
      ],
      "id": "80097c11-3000-416e-8d1b-d3dea3b0fa52",
      "name": "Code3"
    },
    {
      "parameters": {
        "options": {}
      },
      "name": "Set Visited URLs",
      "type": "n8n-nodes-base.set",
      "typeVersion": 2,
      "id": "0515ada7-79ee-4c7f-b312-d5c7f5e75b6a",
      "position": [
        1860,
        320
      ]
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{ $json.url }}",
              "operation": "notContains",
              "value2": "={{ $items('Set Visited URLs')[0].json.value }}"
            }
          ]
        }
      },
      "name": "Filter Unvisited URLs",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "id": "ff5f886c-31f2-42d7-b4a7-93e7c95b5e71",
      "position": [
        2520,
        220
      ]
    },
    {
      "parameters": {
        "url": "https://tailwindcss.com/docs",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        -640,
        -740
      ],
      "id": "c72ffa12-fa84-4752-9df7-d05fca0c227f",
      "name": "HTTP Request2"
    },
    {
      "parameters": {
        "jsCode": "// --- CONFIGURACIÓN ---\n// Define el dominio principal para filtrar enlaces externos.\n// Cambia esto por el dominio del sitio que estás analizando.\nconst MAIN_DOMAIN = 'tailwindcss.com';\n// --------------------\n\nconst htmlString = $input.first().json.data;\n\n// Paso 1: Eliminar etiquetas no deseadas (sin cambios)\nconst cleanedHtml = htmlString\n  .replace(/<script[\\s\\S]*?<\\/script>/gi, '')\n  .replace(/<style[\\s\\S]*?<\\/style>/gi, '')\n  .replace(/<head[\\s\\S]*?<\\/head>/gi, '')\n  .replace(/<noscript[\\s\\S]*?<\\/noscript>/gi, '')\n  .replace(/<meta[^>]*>/gi, '')\n  .replace(/<link[^>]*>/gi, '')\n  .replace(/<svg[\\s\\S]*?<\\/svg>/gi, '')\n  .replace(/<[^>]+>/g, '\\n'); // Quita todas las etiquetas restantes, dejando texto plano\n\n// Paso 2: Extraer texto plano limpio (sin cambios)\nconst plainText = cleanedHtml\n  .replace(/\\n\\s*\\n/g, '\\n')  // Quita líneas vacías múltiples\n  .replace(/\\s{2,}/g, ' ')    // Espacios múltiples -> uno\n  .replace(/^\\s+|\\s+$/g, '')  // Quita espacios iniciales/finales\n  .trim();\n\n// Paso 3: Extraer y FILTRAR enlaces válidos\nconst urlRegex = /<a[^>]*href=[\"']([^\"']+)[\"'][^>]*>(.*?)<\\/a>/gi;\n\n// Función para excluir archivos, anclas y protocolos especiales\nconst isFileOrSpecialLink = (url) => {\n  const excludeExtensions = [\n    '.jpg', '.jpeg', '.png', '.gif', '.svg', '.webp',\n    '.pdf', '.doc', '.docx', '.xls', '.xlsx', '.zip', '.rar', '.csv', '.woff2', '.ttf'\n  ];\n  const lower = url.toLowerCase();\n  return (\n    lower.startsWith('#') ||\n    lower.startsWith('javascript:') ||\n    lower.startsWith('mailto:') ||\n    lower.startsWith('tel:') ||\n    excludeExtensions.some(ext => lower.endsWith(ext)) // Usamos endsWith para mayor precisión\n  );\n};\n\n// NUEVA FUNCIÓN: Verifica si un enlace es interno al dominio principal\nconst isInternalLink = (url, baseDomain) => {\n  // Si empieza con '/', es una ruta relativa del mismo sitio (ej: /docs/installation) -> VÁLIDO\n  if (url.startsWith('/')) {\n    return true;\n  }\n  \n  try {\n    // Intentamos crear un objeto URL para analizarlo\n    const parsedUrl = new URL(url);\n    // Si el hostname termina con nuestro dominio principal (ej: blog.tailwindcss.com) -> VÁLIDO\n    return parsedUrl.hostname.endsWith(baseDomain);\n  } catch (e) {\n    // Si no es una URL válida (ej: un texto cualquiera), lo descartamos\n    return false;\n  }\n};\n\nconst matches = [...htmlString.matchAll(urlRegex)];\nconst urls = matches\n  .map(([_, href, text]) => ({ nombre: text.trim(), url: href.trim() }))\n  .filter(link =>\n    link.url &&\n    link.nombre &&\n    !isFileOrSpecialLink(link.url) && // Mantiene el filtro original\n    isInternalLink(link.url, MAIN_DOMAIN) // AÑADE el nuevo filtro de dominio\n  );\n\nreturn [\n  {\n    json: {\n      contenido: plainText,\n      urls\n    }\n  }\n];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -480,
        -740
      ],
      "id": "b41efa80-12bc-4c33-a1d8-bb91afe43920",
      "name": "Code2"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.splitInBatches",
      "typeVersion": 3,
      "position": [
        2300,
        200
      ],
      "id": "c482ed9f-f23d-4cc0-978e-7e565da47aa0",
      "name": "Loop Over Items1"
    },
    {
      "parameters": {
        "url": "=https://tailwindcss.com{{ $json.urls[0].url }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        2740,
        220
      ],
      "id": "9ee54f1e-add5-4574-8903-fd4c49f9f1a8",
      "name": "HTTP Request3"
    },
    {
      "parameters": {
        "jsCode": "const textContent = $input.first().json.contenido\nconst originUrl =  'https://tailwindcss.com' + $input.first().json.urls[1].url\n\nreturn [{\n  json: {\n    sourceUrl: originUrl,\n    content: textContent,\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3140,
        0
      ],
      "id": "64b75982-4bfd-4606-ac5e-6071e0d3637f",
      "name": "Code4"
    },
    {
      "parameters": {
        "jsCode": "const htmlString = $input.first().json.data;\n\n// Paso 1: Eliminar etiquetas no deseadas\nconst cleanedHtml = htmlString\n  .replace(/<script[\\s\\S]*?<\\/script>/gi, '')\n  .replace(/<style[\\s\\S]*?<\\/style>/gi, '')\n  .replace(//g, '')\n  .replace(/<head[\\s\\S]*?<\\/head>/gi, '')\n  .replace(/<noscript[\\s\\S]*?<\\/noscript>/gi, '')\n  .replace(/<meta[^>]*>/gi, '')\n  .replace(/<link[^>]*>/gi, '')\n  .replace(/<svg[\\s\\S]*?<\\/svg>/gi, '')\n  .replace(/<[^>]+>/g, '\\n'); // Quita todas las etiquetas restantes, dejando texto plano\n\n// Paso 2: Extraer texto plano limpio\nconst plainText = cleanedHtml\n  .replace(/\\n\\s*\\n/g, '\\n')  // Quita líneas vacías múltiples\n  .replace(/\\s{2,}/g, ' ')    // Espacios múltiples -> uno\n  .replace(/^\\s+|\\s+$/g, '')  // Quita espacios iniciales/finales\n  .trim();\n\n// Paso 3: Extraer enlaces válidos\nconst urlRegex = /<a[^>]*href=[\"']([^\"']+)[\"'][^>]*>(.*?)<\\/a>/gi;\n\nconst isExcluded = (url) => {\n  const excludeExtensions = [\n    '.jpg', '.jpeg', '.png', '.gif', '.svg', '.webp',\n    '.pdf', '.doc', '.docx', '.xls', '.xlsx', '.zip', '.rar', '.csv', '.woff2', '.ttf'\n  ];\n  const lower = url.toLowerCase();\n  return (\n    lower.startsWith('#') ||\n    lower.startsWith('javascript:') ||\n    excludeExtensions.some(ext => lower.includes(ext))\n  );\n};\n\nconst matches = [...htmlString.matchAll(urlRegex)];\nconst urls = matches\n  .map(([_, href, text]) => ({ nombre: text.trim(), url: href.trim() }))\n  .filter(link => link.url && link.nombre && !isExcluded(link.url));\n\nreturn [\n  {\n    json: {\n      contenido: plainText,\n      urls\n    }\n  }\n];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2920,
        220
      ],
      "id": "84db60e0-3e54-4fd7-8822-1715fe6342c7",
      "name": "Code5"
    },
    {
      "parameters": {
        "jsCode": "// Iniciar el proceso con la URL semilla\n\nconst startUrl = 'https://tailwindcss.com/docs';\n\n// Inicializar las variables que mantendrán el estado\n$vars.urlsToVisit = [{ url: startUrl }]; // La cola de URLs a visitar\n$vars.visitedUrls = new Set(); // Un conjunto para las URLs ya visitadas\n\n// Devolver la lista inicial para que el bucle comience\nreturn $vars.urlsToVisit;"
      },
      "name": "Initialize1",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2120,
        200
      ],
      "id": "18192f43-2af1-43a5-b39a-2b7de2143509"
    },
    {
      "parameters": {
        "jsCode": "/*\n  Este nodo prepara todo para empezar.\n  Crea un 'estado' inicial que se pasará a través del flujo.\n*/\n\nconst startUrl = 'https://tailwindcss.com/docs';\n\nconst initialState = {\n  // La lista de URLs que faltan por visitar (nuestra cola de trabajo)\n  urls_to_visit: [startUrl],\n  \n  // Un array de URLs que ya hemos procesado para no repetirlas\n  visited_urls: [], // <-- ESTE ES EL CAMBIO MÁS IMPORTANTE\n  \n  // Aquí guardaremos todo el contenido que extraigamos\n  all_content: [],\n\n  // La URL que estamos procesando en la iteración actual\n  current_url: null\n};\n\nreturn initialState;"
      },
      "name": "1. Initialize State",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2460,
        -420
      ],
      "id": "72b8cf07-3c2d-48e8-b379-219c71d713d8"
    },
    {
      "parameters": {
        "conditions": {
          "number": [
            {
              "value1": "={{ $json.urls_to_visit.length }}",
              "operation": "larger"
            }
          ]
        }
      },
      "name": "2. Is Queue Empty?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        2740,
        -440
      ],
      "id": "a60cc59a-6cd2-448e-82e0-24408efb2722"
    },
    {
      "parameters": {
        "jsCode": "/*\n  Este nodo actúa como el gestor de la cola.\n  1. Toma la siguiente URL de la lista 'urls_to_visit'.\n  2. La elimina de la cola.\n  3. La añade a la lista 'visited_urls' para no volver a procesarla.\n  4. Pasa la URL actual al siguiente nodo para la petición HTTP.\n*/\n\nconst state = $input.first().json;\n\n// Sacamos la primera URL de la cola de trabajo\nconst nextUrl = state.urls_to_visit.shift();\n\n// La añadimos al registro de visitadas (usando .push() para el array)\nstate.visited_urls.push(nextUrl);\n\n// La establecemos como la URL actual para esta iteración\nstate.current_url = nextUrl;\n\nreturn state;"
      },
      "name": "3. Get Next URL from Queue",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2920,
        -440
      ],
      "id": "bcfb4580-9621-4ea1-a054-11d34f1708a2"
    },
    {
      "parameters": {
        "url": "={{ $json.current_url }}",
        "options": {
          "response": {}
        }
      },
      "name": "4. HTTP Request",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        3140,
        -440
      ],
      "id": "ef81ea77-bb14-4ef7-9884-4446d4830b75"
    },
    {
      "parameters": {
        "jsCode": "/*\n  Este es el corazón del scraper.\n  1. Procesa el HTML de la página actual.\n  2. Extrae el contenido y lo guarda en 'all_content'.\n  3. Extrae todos los enlaces nuevos.\n  4. Filtra los enlaces para quedarse solo con los válidos y nuevos.\n  5. Añade los enlaces nuevos a la cola 'urls_to_visit' para procesarlos después.\n*/\n\n// FIX 1: Leemos el estado del nodo ANTERIOR al HTTP Request para no perder las listas.\nconst state = $items(\"3. Get Next URL from Queue\")[0].json;\n\n// Leemos el resultado del HTTP Request (el input directo a este nodo).\nconst htmlString = $input.first().json.data;\n\n// Si la petición HTTP falló, el htmlString no existirá. En ese caso, solo devolvemos el estado.\nif (!htmlString) {\n  return state;\n}\n\n// --- EXTRACCIÓN DE CONTENIDO ---\nconst cleanedHtml = htmlString\n  .replace(/<script[\\s\\S]*?<\\/script>/gi, '')\n  .replace(/<style[\\s\\S]*?<\\/style>/gi, '')\n  .replace(/<head[\\s\\S]*?<\\/head>/gi, '')\n  .replace(/<nav[\\s\\S]*?<\\/nav>/gi, '')\n  .replace(/<header[\\s\\S]*?<\\/header>/gi, '')\n  .replace(/<footer[\\s\\S]*?<\\/footer>/gi, '')\n  .replace(/<svg[\\s\\S]*?<\\/svg>/gi, '')\n  .replace(/<[^>]+>/g, '\\n');\n\nconst plainText = cleanedHtml\n  .replace(/\\n\\s*\\n/g, '\\n')\n  .replace(/\\s{2,}/g, ' ')\n  .trim();\n\n// Ahora 'state.all_content' sí existe, porque lo recuperamos al principio del código.\nstate.all_content.push({\n  source: state.current_url,\n  content: plainText\n});\n\n// --- EXTRACCIÓN Y FILTRADO DE ENLACES ---\nconst BASE_URL = 'https://tailwindcss.com';\nconst urlRegex = /<a[^>]*href=[\\\"']([^\\\"']+)[\\\"'][^>]*>/gi;\nconst matches = [...htmlString.matchAll(urlRegex)];\n\nconst newLinks = matches\n  .map(([_, href]) => {\n    // FIX 2: Validamos que el 'href' no esté vacío antes de crear la URL.\n    if (!href) {\n      return null;\n    }\n    try {\n      return new URL(href, BASE_URL).href; // Convierte a URL absoluta\n    } catch (e) {\n      return null; // Descarta URLs mal formadas\n    }\n  })\n  .filter(url => {\n    if (!url) return false;\n    const excludeExtensions = ['.jpg', '.png', '.gif', '.zip', '.pdf', '.svg', '.ico', '.webp'];\n    const lowerUrl = url.toLowerCase();\n    // Debe ser del mismo dominio y no ser un archivo\n    return url.startsWith(BASE_URL) && !excludeExtensions.some(ext => lowerUrl.endsWith(ext));\n  });\n\n// --- ACTUALIZACIÓN DE LA COLA DE TRABAJO ---\nfor (const link of newLinks) {\n  // Solo añadimos la URL si NUNCA la hemos visto antes (usando .includes() para el array)\n  if (!state.visited_urls.includes(link) && !state.urls_to_visit.includes(link)) {\n    state.urls_to_visit.push(link);\n  }\n}\n\nreturn state;"
      },
      "name": "5. Extract Content & Find New Links",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3360,
        -440
      ],
      "id": "19bcac94-8222-469a-91e0-9cd49d42d670"
    },
    {
      "parameters": {},
      "name": "6. Final Result",
      "type": "n8n-nodes-base.noOp",
      "typeVersion": 1,
      "position": [
        3140,
        -200
      ],
      "id": "af3af537-d201-45b1-8358-391bce3ccfc3"
    },
    {
      "parameters": {
        "values": {
          "string": [
            {
              "name": "all_content",
              "value": "={{$json.all_content}}"
            }
          ]
        },
        "options": {}
      },
      "name": "RESULTADO FINAL",
      "type": "n8n-nodes-base.set",
      "typeVersion": 2,
      "position": [
        -220,
        0
      ],
      "id": "28061e27-6892-4c94-bbb5-5d8420b4d94e"
    },
    {
      "parameters": {
        "jsCode": "/*\n  Este nodo prepara todo para empezar.\n  Crea un 'estado' inicial que se pasará a través del flujo.\n*/\n\nconst startUrl = 'https://tailwindcss.com/docs';\nconst urls = $input.first().json.urls.map((url) => {\n  return `https://tailwindcss.com${url.url}`\n})\n\nconst initialState = {\n  // La lista de URLs que faltan por visitar (nuestra cola de trabajo)\n  urls_to_visit: [startUrl, ...urls],\n  \n  // Un array de URLs que ya hemos procesado para no repetirlas\n  visited_urls: [], // <-- ESTE ES EL CAMBIO MÁS IMPORTANTE\n  \n  // Aquí guardaremos todo el contenido que extraigamos\n  all_content: [],\n\n  // La URL que estamos procesando en la iteración actual\n  current_url: null\n};\n\nreturn initialState;"
      },
      "name": "1. Initialize State1",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -320,
        -740
      ],
      "id": "fc921187-c6e6-461e-86c9-511bd3223d96"
    },
    {
      "parameters": {
        "conditions": {
          "number": [
            {
              "value1": "={{ $json.urls_to_visit.length }}",
              "operation": "larger"
            }
          ]
        }
      },
      "name": "2. Is Queue Empty?1",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [
        -140,
        -740
      ],
      "id": "cb6124d0-b691-41f3-9d59-1851fa971ea6"
    },
    {
      "parameters": {
        "jsCode": "/*\n  Este nodo actúa como el gestor de la cola.\n  1. Toma la siguiente URL de la lista 'urls_to_visit'.\n  2. La elimina de la cola.\n  3. La añade a la lista 'visited_urls' para no volver a procesarla.\n  4. Pasa la URL actual al siguiente nodo para la petición HTTP.\n*/\n\nconst state = $input.first().json;\n\n// Sacamos la primera URL de la cola de trabajo\nconst nextUrl = state.urls_to_visit.shift();\n\n// La añadimos al registro de visitadas (usando .push() para el array)\nstate.visited_urls.push(nextUrl);\n\n// La establecemos como la URL actual para esta iteración\nstate.current_url = nextUrl;\n\nreturn state;\n"
      },
      "name": "3. Get Next URL from Queue1",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        80,
        -760
      ],
      "id": "55a7c213-7205-4fea-a5cb-16a20459cb0f"
    },
    {
      "parameters": {
        "url": "={{ $json.current_url }}",
        "options": {
          "response": {}
        }
      },
      "name": "4. HTTP Request1",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        300,
        -760
      ],
      "id": "812cde99-5b00-4f22-a1b9-da0ca9cc2b1c"
    },
    {
      "parameters": {
        "jsCode": "/*\n  Este es el corazón del scraper.\n  1. Procesa el HTML de la página actual.\n  2. Extrae el contenido y lo guarda en 'all_content'.\n  3. Extrae todos los enlaces nuevos.\n  4. Filtra los enlaces para quedarse solo con los válidos y nuevos.\n  5. Añade los enlaces nuevos a la cola 'urls_to_visit' para procesarlos después.\n*/\n\n// Leemos el estado del nodo ANTERIOR al HTTP Request para no perder las listas.\nconst state = $items(\"3. Get Next URL from Queue1\")[0].json;\n\n// Leemos el resultado del HTTP Request (el input directo a este nodo).\nconst htmlString = $input.first().json.data;\n\n// Si la petición HTTP falló, el htmlString no existirá. En ese caso, solo devolvemos el estado.\nif (!htmlString) {\n  return state;\n}\n\n// --- EXTRACCIÓN DE CONTENIDO ---\nconst cleanedHtml = htmlString\n  .replace(/<script[\\s\\S]*?<\\/script>/gi, '')\n  .replace(/<style[\\s\\S]*?<\\/style>/gi, '')\n  .replace(/<head[\\s\\S]*?<\\/head>/gi, '')\n  .replace(/<nav[\\s\\S]*?<\\/nav>/gi, '')\n  .replace(/<header[\\s\\S]*?<\\/header>/gi, '')\n  .replace(/<footer[\\s\\S]*?<\\/footer>/gi, '')\n  .replace(/<svg[\\s\\S]*?<\\/svg>/gi, '')\n  .replace(/<[^>]+>/g, '\\n');\n\nconst plainText = cleanedHtml\n  .replace(/\\n\\s*\\n/g, '\\n')\n  .replace(/\\s{2,}/g, ' ')\n  .trim();\n\n// Ahora 'state.all_content' sí existe, porque lo recuperamos al principio del código.\nstate.all_content.push({\n  source: state.current_url,\n  content: plainText\n});\n\n// --- EXTRACCIÓN Y FILTRADO DE ENLACES ---\nconst BASE_URL = 'https://tailwindcss.com';\nconst urlRegex = /<a[^>]*href=[\"']([^\"']+)[\"'][^>]*>/gi;\nconst matches = [...htmlString.matchAll(urlRegex)];\n\nconst newLinks = matches\n  .map(([_, href]) => {\n    // Validamos que el 'href' no esté vacío antes de crear la URL.\n    if (!href) {\n      return null;\n    }\n    try {\n      return new URL(href, BASE_URL).href; // Convierte a URL absoluta\n    } catch (e) {\n      return null; // Descarta URLs mal formadas\n    }\n  })\n  .filter(url => {\n    if (!url) return false;\n    const excludeExtensions = ['.jpg', '.png', '.gif', '.zip', '.pdf', '.svg', '.ico', '.webp'];\n    const lowerUrl = url.toLowerCase();\n    // Debe ser del mismo dominio y no ser un archivo\n    return url.startsWith(BASE_URL) && !excludeExtensions.some(ext => lowerUrl.endsWith(ext));\n  });\n\n// --- ACTUALIZACIÓN DE LA COLA DE TRABAJO ---\nfor (const link of newLinks) {\n  // Solo añadimos la URL si NUNCA la hemos visto antes (usando .includes() para el array)\n  if (!state.visited_urls.includes(link) && !state.urls_to_visit.includes(link)) {\n    state.urls_to_visit.push(link);\n  }\n}\n\nreturn state;\n"
      },
      "name": "5. Extract Content & Find New Links1",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        520,
        -760
      ],
      "id": "88efe2a7-82be-4bf7-953a-f9efb8586ca6"
    },
    {
      "parameters": {
        "mode": "insert",
        "pineconeIndex": {
          "__rl": true,
          "value": "tailwind-documentation",
          "mode": "list",
          "cachedResultName": "tailwind-documentation"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.vectorStorePinecone",
      "typeVersion": 1.2,
      "position": [
        720,
        -760
      ],
      "id": "97be25f0-f5c2-4db1-a1c3-0862a8b41f1d",
      "name": "Pinecone Vector Store",
      "credentials": {
        "pineconeApi": {
          "id": "TjNb4QvfXePYJ8y9",
          "name": "PineconeApi account"
        }
      }
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.embeddingsOpenAi",
      "typeVersion": 1.2,
      "position": [
        780,
        -540
      ],
      "id": "635d6d15-34bc-4ab3-aaaf-7fef7b7af3bc",
      "name": "Embeddings OpenAI",
      "credentials": {
        "openAiApi": {
          "id": "UYsXoFpwT6Oh1GeF",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.documentDefaultDataLoader",
      "typeVersion": 1,
      "position": [
        960,
        -540
      ],
      "id": "e2e0a1fe-445e-42a7-8b30-0f541330b578",
      "name": "Default Data Loader"
    },
    {
      "parameters": {
        "chunkSize": 1500,
        "chunkOverlap": 150
      },
      "type": "@n8n/n8n-nodes-langchain.textSplitterCharacterTextSplitter",
      "typeVersion": 1,
      "position": [
        980,
        -400
      ],
      "id": "d03d74c4-be6a-4443-8c86-0170ee49a45f",
      "name": "Character Text Splitter"
    },
    {
      "parameters": {
        "operation": "getAll",
        "calendar": {
          "__rl": true,
          "mode": "list",
          "value": ""
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleCalendar",
      "typeVersion": 1.3,
      "position": [
        0,
        0
      ],
      "id": "6f82a0fe-d0ce-4395-b5e1-c110924b48e6",
      "name": "Get many events",
      "credentials": {
        "googleCalendarOAuth2Api": {
          "id": "RMuQyYsn6eGZTZPX",
          "name": "hola@whitelabel.lat"
        }
      }
    }
  ],
  "pinData": {},
  "repo_name": "flujos_n8n",
  "repo_owner": "whitelabel-ai",
  "repo_path": "Automation/",
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [],
  "triggerCount": 0,
  "updatedAt": "2025-06-18T06:37:30.802Z",
  "versionId": "7fc441a5-ff7f-4a4d-8050-bad57609a921"
}